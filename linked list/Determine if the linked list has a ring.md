# 有环时两个指针一定会相遇的数学证明

在做这道题的时候可能会有疑惑：为什么在有环的时候两个指针一定会相遇？这里给出数学证明。

当 slow 指针一步步走到环的入口时（注意此时 fast 已经在环里了，因为它比 slow 要快），设：

链表头指针 head 到链表环的入口处的距离为  L1
fast 指针距离环的入口的距离为 L2
fast 已经在环内走了 N1 圈（向下取整）
假设 slow 再经过 i 步与 fast 相遇
环的周长为 C
fast 和 slow 走过的总路程分别为 disFast 和 disSlow
## 示意图如下：

![Image text](https://raw.githubusercontent.com/OneStepAndTwoSteps/data_structure/master/static/1.jpg)

则当 slow 走到环入口时，可得知：

disFast = L1 + L2 + N1C 

disSlow = L1 

又因为 fast 每次走两步，即比 slow 快一倍，所以若两个指针相遇，则有：

 (disSlow + i - L1) mod C = (disFast + 2i - L1) mod C 

减去 L1 是为了减掉不在环内的长度从而求得相遇点相对于环入口的距离（按照指针前进方向算），由于等式两边的值实际上是相对于环入口的距离，所以有：

i modC = (L2 + N1C + 2i) mod C 

(L2 + N1C + i) mod C = 0 

(L2 + i) mod C = 0  (加减 C 的整数倍对于取余来说没有影响） 

可以看到， L2 和  i 的总和等于环的周长的整数倍，这个等式是成立的。实际上我们也求出了 i 的值。结合图和最终的等式，我们可以看到，对于任意 L2 ，
都可以求出无数个 i 值，每个值都对应一个周长的整数倍，而对于每一个  i 值，最终相遇的位置都一样，这也很好理解，当 slow 和 fast 相遇后，
由于 2 倍速度的关系，当 slow 继续走半圈的时候，fast 走了一圈回到了之前的相遇点，当 slow 再走半圈回到之前的相遇点， 
fast 又走了一圈再次回到之前的相遇点。

这就是对于在有环的单链表中快慢指针一定会相遇的数学证明。



# 求环的入口
在上一个问题之后，还有一个相关的问题，即如果此链表有环，求环的入口节点。直接想此算法可能比较难解，所以这个问题可以尝试着从数学上入手。

数学
设 (注意与上一个问题所表示的含义可能有不同) ：

L1 为链表头 head 到环入口的距离
L2 为从环入口向前到相遇点的距离 (按照指针前进的方向计算)
L3 为从相遇点向前到环入口的距离 (按照指针前进的方向计算)
C 为环的周长
N1 和 N2 分别为 slow 和 fast 在相遇时走过的圈数（向下取整）
disSlow  和 disFast 分别为 slow 和 fast 在相遇时走过的距离
## 示意图如下：

![Image text](https://raw.githubusercontent.com/OneStepAndTwoSteps/data_structure/master/static/2.jpg)



则：

disSlow = L1 + L2 + N1C

disFast = L1 + L2 + N2C 

又因为 fast 速度是 slow 的 2 倍，所以：

disSlow * 2 = disFast 

2(L1 + L2 + N1C) = L1 + L2 + N2C 

L1 + L2 + 2N1C = N2C 
L1 = (N2 - 2N1)C - L2 

因为 fast 的速度是 slow 的两倍，所以 N2至少是 N1 的两倍（至少而不是恰好是因为 fast 进入环时 slow 可能还没进入环，所以 fast 可能会先在环内走几圈），

即

N2 >= 2N1 

这里其实还可以求出的是，当  N2 等于 2 倍的 N1 的时候， L1 和 L2 都为 0 ，也就是整个链表就是一个环 。

由此可以看出， L1 即链表头 head 到环入口的距离就等于 (N2 - 2N1)C - L2 ，其实就等于  L3 + (N2 - 2N1 - 1)C 
（注意 L3 是按照指针前进方向算的，并不是最小距离，所以这个结果对于整个链表都是环也是有效的） ，而从相遇点向前走 L3 + (N2 - 2N1 - 1)C 的距离，
正好就走到了环的入口（如果没理解可以在图上比划一下即可），所以我们就可以推导出算法，即：
让两个指针其中一个从链表头 head 出发，一次走一步，让另一个指针从相遇点出发，也一次走一步，相遇点就是环的入口。


## 笔记
第一个部分判断是否有环，判断的时候除以周长取余，可以这样理解比如我们在操场跑步，有的人跑的快有的人跑的慢，跑的快的人最后肯定会和跑的慢的人相遇，那在哪里
相遇呢？

文中除以周长c取余表示的就是从环点开始到相遇点的距离呀，因为 距离/周长  余出来的就是原点到相遇点的距离了。



第二个部分的 
 由此可以看出， L_1 即链表头 head 到环入口的距离就等于 (N_2 - 2N_1)C - L_2 ，其实就等于  L_3 + (N_2 - 2N_1 - 1)C 
 （注意 L_3 是按照指针前进方向算的，并不是最小距离，所以这个结果对于整个链表都是环也是有效的） ，而从相遇点向前走 L_3 + (N_2 - 2N_1 - 1)C 的距离，
 正好就走到了环的入口（如果没理解可以在图上比划一下即可），所以我们就可以推导出算法，即：
 让两个指针其中一个从链表头 head 出发，一次走一步，让另一个指针从相遇点出发，也一次走一步，相遇点就是环的入口。
 
 
 我们最后可以得出的是 L1=L3+(N2-2N1-1)C   后面的(N2-2N1-1)C表示的就是圈数呀，在一个环中不论你跑多少圈，只要是圈的整数倍，那你的位置还是不变的呀
 所以这样我们就可以得出L1=L3了，所以得出 让两个指针其中一个从链表头 head 出发，一次走一步，让另一个指针从相遇点出发，也一次走一步，相遇点就是环的入口。
